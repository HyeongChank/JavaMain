package DataStructure_StrackQueue;

import java.util.LinkedList;
import java.util.Scanner;

public class Queue{
	
	
		
	
	
	
	
	
	public static void main(String[] args) {
		
		int capacity =10;
		int front =0;
		int rear =0;
		LinkedList<Integer> que = new LinkedList<Integer>();
		Scanner kb = new Scanner(System.in);
		int a = kb.nextInt();
		int b = kb.nextInt();
		System.out.println("1.추가" + " 2.삭제" + " 3.전체삭제 " + " 4. 현재 큐자료");
		switch(a) {
		case 1 : if(front !=capacity) {
			System.out.println("작성");
			que.push(b);
			front++;
		}
		case 2 : if(front ==0) {
			System.out.println("없음");
		}
		else {que.poll();
		}
		}
//		case 3 : 
//		System.out.println("추가할 정보를 적으시오.");
//		while(true) {
//			if(!que.isEmpty()) {
//	
//				que.push(a);
//				front++;
//				System.out.println(front);
//			}
//			if(front-capacity ==0) {
//				System.out.println("가득찼습니다");
////	
//				que.poll();
//				que.push(a);
//			}
//			System.out.println(que);
//			
//		}
		System.out.println(que);
		
//		
//		
//		
//		
//		que.poll();
//		
//		System.out.println(que);
//		que.pop();
//		System.out.println(que);
	}
}



//	public class Queue {
//
//	    private final int MAX_SIZE = 5;
//	    private int front, rear;
//	    private int[] queue;
//
//	    public Queue2() {
//	        front = rear = 0;
//	        queue = new int[MAX_SIZE];
//	    }
//
//	    // front와 rear이 같은 위치에 있다면 큐가 비어있다는 뜻이다.
//	    private boolean isEmpty() {
//	        return front == rear;
//	    }
//	    // rear이 front의 바로 전 위치에 있다면 큐가 가득찼다는 뜻이다.
//	    private boolean isFull() {
//	        return (rear+1) % MAX_SIZE == front;
//	    }
//	    // 데이터가 들어갈 땐 rear만 움직인다. 
//	    // rear의 위치는 최근에 들어온 데이터의 위치이다. 
//	    // 즉, 새로운 데이터가 들어오기 위해 먼저 이동해야한다.
//	    public void enqueue(int data) {
//	        // 큐가 가득차면 들어갈 수 없다 -> 리턴
//	        if (isFull())
//	            System.out.println("It's FULL!!!");
//	            // 큐에 자리가 있다면 데이터를 넣는다.
//	        else {
//	            rear = (++rear) % MAX_SIZE; //원형 큐이기 때문에 순환한다.
//	            queue[rear] = data;
//	        }
//	    }
//	    // 데이터가 나갈 땐 front만 움직인다. 
//	    public int dequeue() {
//	        int preIndex;
//	        // 큐가 비어있다면 데이터를 뺄 수 없다. 나는 데이터가 없다는 신호로 -1을 리턴했다(임시 정의)
//	        if (isEmpty())
//	            return -1;
//	            // 큐에 데이터가 있다면 데이터를 뺀다. front 이동(증가)
//	        else {
//	            preIndex = front;
//	            front = (++front) % MAX_SIZE;
//	        }
//	        return queue[preIndex];
//	    }
//
//	    public void display() {
//	        System.out.println("FRONT :"+front+" REAR :"+rear);
//	        System.out.print("QUEUE DATA: ");
//	        for(int index = front + 1; index != (rear+1) % MAX_SIZE; index = (index+1) % MAX_SIZE)
//	            System.out.print(queue[index] + " ");
//	        System.out.println();
//	        System.out.println();
//	    }
//	}
//
//
//
//
//
//class Queue
//{
//public:
//	Queue(int queueCapacity = 10);
//	bool IsEmpty();
//	T& Front();
//	T& Rear();
//	void Push(T const& x);
//	void Pop();
//private:
//	T* queue;
//	int front;
//	int rear;
//	int capacity;
//};
//
//Queue<T>::Queue(int queueCapacity) : capacity(queueCapacity)
//{
//	queue = new T[capacity];
//	front = rear = -1;
//}
//
//template <class T>
//inline bool  Queue<T>::IsEmpty() { return front == rear; }
//
//template <class T>
//void Queue<T>::Push(T const& x)
//{
//	if ((rear + 1) % capacity == front)
//	{
//	   //throws
//	}
//
//	rear = (rear + 1) % capacity;
//	queue[rear] = x;
//}
//
//template <class T>
//void Queue<T>::Pop()
//{
//	if (IsEmpty()) throw "Queue is empty. Cannot delelte.";
//	front = (front + 1) % capacity;
//	queue[front].~T();
//}
